# """
# 输出100以内的素数

# 本程序用于计算并输出100以内的所有素数。
# 素数是只能被1和自身整除的大于1的自然数。
# 程序使用了试除法来判断素数，并采用了只检查到平方根的优化方法。

# Version: 1.0
# Author: 骆昊
# """

# # 遍历2到99的所有数字
# for num in range(2, 100):
#     # 假设当前数字是素数
#     is_prime = True
#     # 只需要检查到平方根，这是一个重要的优化
#     # 因为如果一个数不是素数，它的因子中至少有一个不大于它的平方根
#     for i in range(2, int(num ** 0.5) + 1):
#         # 如果能被整除，说明不是素数
#         if num % i == 0:
#             is_prime = False
#             break    # 找到一个因子后就可以停止检查
#     # 如果经过所有检查后仍然是素数，就输出该数
#     if is_prime:
#         print(num)


"""
输出斐波那契数列中的前20个数

斐波那契数列是一个以递推方式定义的数列，其中每个数字是前两个数字的和。
数列从0和1开始，接下来的数字依次为1, 2, 3, 5, 8, 13, 21, 34...
这个程序将输出斐波那契数列的前20个数。

# Version: 1.0
# Author: 骆昊
#"""
# # 初始化斐波那契数列的前两个值
# # a表示当前数列中的数，b表示下一个数
# a, b = 0, 1

# # 循环20次，生成20个斐波那契数
# # 使用下划线(_)作为循环变量表示我们不关心这个变量的具体值
# for _ in range(30): # 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
#     # 同时更新a和b的值
#     # a更新为b的值（当前的下一个数变成当前数）
#     # b更新为a+b的值（计算新的下一个数，即当前两个数的和）
#     # 注意：右侧的a和b是更新前的值
#     print('---',_,'---')
#     # a, b = b, a + b
#     # 斐波那契数列状态更新：(a, b) -> (b, a+b)
#     # 假设在此代码块执行前:
#     #   a 代表 F_n (序列中的当前斐波那契数)
#     #   b 代表 F_{n+1} (序列中的下一个斐波那契数)
#     # 执行此代码块后，目标是:
#     #   a 更新为 F_{n+1}
#     #   b 更新为 F_{n+2} (F_n + F_{n+1})

#     # 步骤 1: 将变量 a 的当前值 (F_n) 临时存储起来。
#     # 这是必需的，因为在下一步中，a 的值将被 b 的当前值 (F_{n+1}) 覆盖。
#     # 为了能够正确计算 F_{n+2} (它依赖于 F_n 和 F_{n+1})，我们需要保留 a 的原始值 (F_n)。
#     temp = a
#     # 步骤 2: 更新变量 a 的值。
#     # 将变量 b 的当前值 (F_{n+1}) 赋给 a。执行此行后，a 中存储的是 F_{n+1}。
#     a = b
#     # 步骤 3: 更新变量 b 的值，计算得到新的斐波那契数 F_{n+2}。
#     # 新的 b (即 F_{n+2}) 是通过将 a 的原始值 (F_n，现存储在 temp 中)
#     # 与 b 的原始值 (F_{n+1}，在执行此行赋值操作前 b 仍然持有该值) 相加得到的。
#     b = temp + b
#     # a = b # 1
#     # b = a + b # 1 + 1 = 2

#     print(a)


# """
# 寻找水仙花数 要求：找出 100 到 999 范围内的所有水仙花数。
# 水仙花数是指一个 3 位数，其各位数字立方和等于该数本身。
# 例如：153 = 1^3 + 5^3 + 3^3
# 100-999
# 153 = 1^3 + 5^3 + 3^3
# 1634 = 1^4 + 6^4 + 3^4 + 4^4
# 100-999
# 153 = 1^3 + 5^3 + 3^3
# 1634 = 1^4 + 6^4 + 3^4 + 4^4

# """
# 找出100到999范围内的水仙花数

# Author: 骆昊
# """
# # % 是取模运算符（Modulo Operator）。它返回除法的余数。例如，10 % 3 的结果是 1，因为10除以3等于3余1。在你的代码中，num % 10 用于获取 num 的个位数，而 num // 10 % 10 用于获取 num 的十位数。

# # // 是整数除法运算符（Floor Division Operator）。它返回除法结果的整数部分（向下取整）。例如，10 // 3 的结果是 3，而 9 // 4 的结果是 2。在你的代码中，num // 10 用于去掉 num 的个位数，num // 100 用于获取 num 的百位数。

# for num in range(100, 1000): # 100-999
#     low = num % 10 # 个位
#     mid = num // 10 % 10 # 十位
#     high = num // 100 # 百位
#     if num == low ** 3 + mid ** 3 + high ** 3:
#         print(num)


# """
# 正整数的反转

# Version: 1.0
# Author: 骆昊
# """
# num = int(input('num = '))
# reversed_num = 0
# while num > 0:
#     reversed_num = reversed_num * 10 + num % 10 # num % 10 取个位
#     print('reversed_num:',reversed_num)
#     num = num // 10 # num % 10 取十位及以上直到为0
#     print('num:',num)
#     print('---')
# print(reversed_num)


# """
# 正整数的反转 - 将输入的正整数倒过来显示
# 例如：输入12345，输出54321

# Version: 1.0
# Author: 骆昊
# """
# # 从用户获取一个正整数
# num = int(input('num = '))
# # 初始化存储反转后数字的变量
# reversed_num = 0

# # 当输入的数字大于0时继续循环
# while num > 0:
#     # 取出num的最后一位数字(个位)，并将其添加到reversed_num的末尾
#     # 例如：如果reversed_num=0，num=123，则reversed_num变为0*10+3=3
#     # 下一轮：如果reversed_num=3，num=12，则reversed_num变为3*10+2=32
#     reversed_num = reversed_num * 10 + num % 10

#     # 去掉num的最后一位数字(整除10，丢弃个位)
#     # 例如：123 // 10 = 12
#     num //= 10  # 等同于 num = num // 10

# # 输出反转后的数字
# print(reversed_num)


# 例子4：百钱百鸡问题（优化枚举）
"""
百钱百鸡问题：
公鸡每只5钱，母鸡每只3钱，小鸡三只1钱。
用100钱买100只鸡，问公鸡、母鸡、小鸡各多少只？

设公鸡 x 只，母鸡 y 只，小鸡 z 只。
x + y + z = 100
5x + 3y + z/3 = 100  => 15x + 9y + z = 300

消去z:
15x + 9y + (100 - x - y) = 300
14x + 8y = 200
7x + 4y = 100

约束：
x >= 0, y >= 0, z >= 0
x, y, z 均为整数
z % 3 == 0 (因为小鸡3只1钱，所以小鸡数量必须是3的倍数)
由 7x = 100 - 4y 可知，7x 为偶数，故 x 为偶数。
x <= 100/7 约等于14
"""
# solutions = []
# # x: 公鸡数量
# # x 必须是偶数，且 7x <= 100  => x <= 14
# for x in range(0, 14 + 1, 2):
#     print(x)
#     print("------1----")
#     # 7x + 4y = 100  => 4y = 100 - 7x
#     val_for_4y = 100 - 7 * x

#     # y 必须是整数且 y >= 0
#     # 检查 val_for_4y 是否满足两个条件:
#     # 1. val_for_4y >= 0：确保 y 不会是负数
#     # 2. val_for_4y % 4 == 0：确保 y 是整数（因为 val_for_4y 是 4y）
#     if val_for_4y >= 0 and val_for_4y % 4 == 0:
#         y = val_for_4y // 4  # y: 母鸡数量
#         print(y)
#         print("------2----")
#         # x + y + z = 100 => z = 100 - x - y
#         z = 100 - x - y  # z: 小鸡数量

#         # z 必须是整数, z >= 0 且 z % 3 == 0
#         if z >= 0 and z % 3 == 0:
#             print(z)
#             print("------3----")
#             solutions.append((x, y, z))

# # 打印结果
# print("\n百钱百鸡问题的所有解法：")
# if solutions:
#     for sol in solutions:
#         print(f"公鸡: {sol[0]}, 母鸡: {sol[1]}, 小鸡: {sol[2]}")
# else:
#     print("没有找到解法。")


"""
CRAPS赌博游戏
这是一个模拟CRAPS（花旗骰）赌博游戏的程序。
游戏规则：
1. 玩家初始有1000元赌注
2. 每局开始前玩家下注
3. 第一轮：
   - 摇出7或11点 -> 玩家胜
   - 摇出2、3或12点 -> 庄家胜
   - 其他点数记为"目标点"，继续游戏
4. 后续轮次：
   - 摇出7点 -> 庄家胜
   - 摇出目标点 -> 玩家胜
   - 其他点数继续摇骰子
5. 游戏结束条件：玩家破产（赌注为0）

Version: 1.0
Author: 骆昊
"""

# 导入random模块，用于生成随机数
import random

def roll_dice():
    """
    模拟掷两个骰子并返回点数和
    使用random.randint(1, 6)分别生成两个1-6之间的随机数，模拟两个骰子

    Returns:
        int: 两个骰子的点数和（范围：2-12）
    """
    # 生成第一个骰子的点数(1-6)并与第二个骰子的点数相加
    return random.randint(1, 6) + random.randint(1, 6)

def get_valid_bet(money):
    """
    获取并验证玩家的下注金额

    Args:
        money (int): 玩家当前的资金总额

    Returns:
        int: 有效的下注金额（大于0且不超过当前资金）

    说明：
    - 使用无限循环直到获取到有效输入
    - 使用try-except处理非数字输入
    - 验证下注金额的合理性
    """
    while True:  # 持续循环直到获得有效输入
        try:
            # 提示用户输入下注金额，并转换为整数
            bet = int(input(f'您的总资金为{money}元，请下注: '))
            # 验证下注金额是否在有效范围内
            if 0 < bet <= money:
                return bet
            # 如果金额无效，提示错误信息
            print('下注金额必须大于0且不能超过总资金')
        except ValueError:
            # 处理输入无法转换为整数的情况
            print('请输入有效的数字')

def play_game():
    """
    CRAPS游戏的主要逻辑实现函数

    游戏流程：
    1. 初始化玩家资金
    2. 循环进行游戏，直到玩家破产或选择退出
    3. 每轮游戏包含下注和掷骰子环节
    4. 根据规则判定输赢并更新资金
    """
    money = 1000  # 设置初始资金为1000元

    # 只要玩家还有钱就可以继续游戏
    while money > 0:
        # 获取玩家的有效下注金额
        bet = get_valid_bet(money)
        # 第一次掷骰子
        first_roll = roll_dice()
        print(f'第一次摇出了{first_roll}点')

        # 判断第一轮的结果
        if first_roll in (7, 11):  # 如果第一轮摇出7或11点
            print('玩家胜!')
            money += bet  # 玩家获胜，增加赌注
        elif first_roll in (2, 3, 12):  # 如果第一轮摇出2、3或12点
            print('庄家胜!')
            money -= bet  # 庄家获胜，扣除赌注
        else:  # 如果摇出其他点数，记为目标点数，继续游戏
            print(f'目标点数是{first_roll}')
            # 继续掷骰子直到分出胜负
            while True:
                current_roll = roll_dice()
                print(f'摇出了{current_roll}点')

                # 判断后续轮次的结果
                if current_roll == 7:  # 如果摇出7点
                    print('庄家胜!')
                    money -= bet  # 庄家获胜，扣除赌注
                    break
                elif current_roll == first_roll:  # 如果摇出与第一轮相同的点数
                    print('玩家胜!')
                    money += bet  # 玩家获胜，增加赌注
                    break
                # 其他情况继续掷骰子

        # 显示当前资金状况
        print(f'您现在有{money}元')
        # 检查是否破产
        if money <= 0:
            print('游戏结束，您破产了!')
            break

        # 询问是否继续游戏
        # lower()将输入转换为小写，startswith('y')检查是否以'y'开头
        if not input('是否继续游戏？(y/n) ').lower().startswith('y'):
            print(f'您最终的资金为{money}元')
            break

# 当直接运行此脚本时执行游戏
if __name__ == '__main__':
    play_game()
